//! handles the steps ast -> intermediate byte code -> final bytecode
//!
//! The compilation from ast to intermediate bytecode is handled via the Compilable trait,
//! that is implemented by all Ast node types. The definition and implementation of this trait
//! reside in this file.

use thiserror::Error;

use crate::{
    core::*,
    type_inference::{EnvironmentIdentifier, TypeIndex},
    vm,
};
use std::result::Result as StdResult;

/// The errors that can occur during compilation
#[derive(Error, Debug)]
pub enum CompilationError {
    #[error("Undefined Symbol: {name}")]
    UndefinedSymbol { ast_id: usize, name: String },

    #[error("A compiler bug was detected: {msg}")]
    CompilerBug { ast_id: usize, msg: String },

    #[error("Found {found:?} arguments, expected {expected:?}")]
    ArgCount {
        ast_id: usize,
        found: Vec<DataType>,
        expected: Signature,
    },

    #[error("Argument is of type {actual:?} but needs to be {expected:?}")]
    TypeError {
        ast_id: usize,
        actual: DataType,
        expected: TypeSet,
    },
}

impl CompilationError {
    pub fn get_ast_id(&self) -> usize {
        match self {
            Self::UndefinedSymbol { ast_id, .. } => *ast_id,
            Self::CompilerBug { ast_id, .. } => *ast_id,
            Self::ArgCount { ast_id, .. } => *ast_id,
            Self::TypeError { ast_id, .. } => *ast_id,
        }
    }
}

pub type Result<T> = StdResult<T, CompilationError>;

/// Handles first part of compilation
pub trait Compilable {
    /// Produces bytecode.
    ///
    /// Extends the provided builder with itself. The TypeIndex is the result of
    /// [`crate::type_inference::infer_ast_types`] and contains the type of all values that are
    /// generated by Expr-Ast-Nodes.
    fn compile(&self, builder: ByteCodeBuilder, expr_types: &TypeIndex) -> Result<ByteCodeBuilder>;
}

macro_rules! compiler_bug {
    ($ast_id:expr, $msg:literal $(, $args:expr)*) => {
        return Err(CompilationError::CompilerBug {
            ast_id: $ast_id,
            msg: format!($msg $(, $args)*)
        });
    };
}

impl Compilable for FnFragment {
    fn compile(
        &self,
        mut builder: ByteCodeBuilder,
        expr_types: &TypeIndex,
    ) -> Result<ByteCodeBuilder> {
        todo!();
    }
}

impl Compilable for Call {
    fn compile(
        &self,
        mut builder: ByteCodeBuilder,
        expr_types: &TypeIndex,
    ) -> Result<ByteCodeBuilder> {
        let Call { id, callee, args } = self;
        let Expr::Symbol(Symbol(callee_id, callee_name)) = callee.as_ref() else {
            compiler_bug!(callee.get_id().into(),"Calling something that is not a symbol is not supported yet" );
        };
        let callee_type = expr_types
            .get(&EnvironmentIdentifier::AstId(*callee_id))
            .expect("Missing Entry in type idx");
        let DataType::Callable(CallableType::Builtin, callee_sign) = callee_type else {
                    compiler_bug!(*callee_id, "Currently only calling built ins is supported");
                };
        let opcode =
            vm::built_ins::opcode(callee_name).expect(&format!("invalid builtin: {}", callee_name));
        let old_builder = builder.clone();
        builder.open_scope(*id);
        for (a, t) in args.iter().zip(&callee_sign.args) {
            builder = a.compile(builder, expr_types)?;
            if !builder.check_and_fix_type_of_stack_top(&t) {
                return Err(CompilationError::TypeError {
                    ast_id: a.get_id().into(),
                    actual: expr_types.get(&a.get_id()).unwrap().clone(),
                    expected: t.clone(),
                });
            }
        }

        // The above loop will not compile the expressions for the variadic arguments.
        // because zip stops at the shorter iter, so this needs to be done here
        if let Some(t) = &callee_sign.var_arg {
            for arg in args.iter().skip(callee_sign.args.len()) {
                builder = arg.compile(builder, expr_types)?;
                if !builder.check_and_fix_type_of_stack_top(&t) {
                    return Err(CompilationError::TypeError {
                        ast_id: arg.get_id().into(),
                        actual: expr_types.get(&arg.get_id()).unwrap().clone(),
                        expected: t.clone(),
                    });
                }
            }
        }
        assert!(
            builder.stack_info.len() == old_builder.stack_info.len() + args.len(),
            "Stack has the wrong amount of arguments"
        );
        let n_var_args = if callee_sign.var_arg.is_some() {
            Some(args.len() - callee_sign.args.len())
        } else {
            None
        };
        if let Some(n) = n_var_args {
            builder.push_primitive_to_stack(n.into(), *id);
        }
        builder.text.push_back(opcode);
        builder.create_value_in_memory(&callee_sign.result.concrete_type().unwrap(), *id);
        builder.collapse_scope();
        Ok(builder)
    }
}

impl Compilable for Let {
    fn compile(
        &self,
        mut builder: ByteCodeBuilder,
        expr_types: &TypeIndex,
    ) -> Result<ByteCodeBuilder> {
        let Let {
            id,
            symbol_name,
            value_expr,
        } = self;

        let old_builder = builder.clone();
        builder = value_expr.compile(builder, expr_types)?;
        assert_stack_grew_by_one(*id, &old_builder, &builder);
        builder.add_symbol_for_stack_top(symbol_name);
        Ok(builder)
    }
}

impl Compilable for StrLit {
    fn compile(&self, mut builder: ByteCodeBuilder, _: &TypeIndex) -> Result<ByteCodeBuilder> {
        let StrLit(id, val) = self;
        builder.add_to_datasection_and_push_ref(Value::Str(val.clone()), *id);
        Ok(builder)
    }
}

impl Compilable for Symbol {
    fn compile(
        &self,
        mut builder: ByteCodeBuilder,
        expr_types: &TypeIndex,
    ) -> Result<ByteCodeBuilder> {
        let Symbol(ast_id, name) = self;
        map_to_symbol_not_found(builder.copy_symbol_target_to_stack_top(name), *ast_id, name)?;
        Ok(builder)
    }
}

impl Compilable for IntLit {
    fn compile(
        &self,
        mut builder: ByteCodeBuilder,
        expr_types: &TypeIndex,
    ) -> Result<ByteCodeBuilder> {
        let IntLit(id, val) = self;
        builder.push_primitive_to_stack(CopyValue::Int(*val), *id);
        Ok(builder)
    }
}

impl Compilable for Block {
    fn compile(
        &self,
        mut builder: ByteCodeBuilder,
        expr_types: &TypeIndex,
    ) -> Result<ByteCodeBuilder> {
        let Block(id, phrases) = self;

        builder.open_scope(*id);
        for term in phrases {
            builder = term.compile(builder, expr_types)?;
        }
        builder.collapse_scope();
        Ok(builder)
    }
}

fn map_to_symbol_not_found<T, E>(
    res: StdResult<T, E>,
    ast_id: usize,
    symbol_name: &str,
) -> StdResult<T, CompilationError> {
    res.map_err(|_| CompilationError::UndefinedSymbol {
        ast_id,
        name: symbol_name.into(),
    })
}

fn assert_stack_grew_by_one(id: usize, old: &ByteCodeBuilder, new: &ByteCodeBuilder) {
    if !(old.stack_info.len() + 1 == new.stack_info.len()) {
        panic!(
            "During compilation of an expression. (Ast-id: {}) \n\
            The stack size should have increase by one, but it didnt",
            id
        );
    }
}
