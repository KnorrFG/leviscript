//! This file defines the opcodes,

//! And some utility types and functions.
//! There is a lot of code gen going on here by means of the OpCode derive-macro.
//! I consider the macro part of this crate, even though it is technically a sub-crate.
//! Therefore I liberally use types in the code generation, because I know they exist, instead
//! of somehow getting them into the macro. For an independent macro crate, this would be a no-go
//! but in this private scenario, I think it's fine. The vm::* imports are here because of the
//! codegen, btw

use proc_macros::OpCode;

// this import is here to have the exec_... functions in scope
use crate::core::*;
use crate::vm::*;

/// Representing Opcodes, all variants must have zero or one member.
/// This way, it's possible to simply convert between an object and it's raw representation
/// Most impls are generated by the
/// [OpCode macro](proc_macros::OpCode)
#[derive(Debug, Clone, Copy, OpCode, PartialEq)]
pub enum OpCode {
    Exit(i32),
    PushDataSecRef(usize),
    PushPrimitive(CopyValue),
    /// makes a copy of the entry at the given index and puts it on top of the stack
    RepushStackEntry(usize),
    /// coppies the stack top to the register addressed by the u8
    StackTopToReg(u8),
    /// coppies the value from the register to the top of the stack
    ReadReg(u8),
    /// Pops a value from the stack
    Pop,
    /// Pops a value from the stack. Must be a reference. Frees the value behind
    /// the ref
    PopFree,
    ToStr,
    ToBool,
    Exec,
    StrCat,
}

impl OpCode {
    /// Patches DataRefs in OpCode args
    /// The OpCode macro could generate this too
    ///
    /// If you combine multiple chunks of opcodes, references to the data section will become
    /// invalid. This function allows updating the references
    pub fn offset_data_section_addr(&mut self, offset: usize) {
        use OpCode::*;
        match self {
            PushDataSecRef(r) => *r += offset,
            _ => {}
        };
    }

    pub fn get_cast(from: &DataType, to: &DataType) -> Option<Self> {
        match (from, to) {
            _ => None,
        }
    }
}
