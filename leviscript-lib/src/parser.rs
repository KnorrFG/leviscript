//! implements parsing.
//!
//! This is a two-fold process. First, we use pest to generate a Parser that returns
//! a parse tree, which is then converted into an abstract syntax tree by the [`to_ast`] function
//! The generation of the parse tree is implemented automatically by means of a grammar (using the
//! [`pest`] crate), which you can find in `<crateroot>/grammar.pest`

use pest::error::Error;
use pest_derive::Parser;

use crate::{core::*, utils::to_str_vec};

use std::matches;

pub use pest::{
    error::{Error as PestError, ErrorVariant as PestErrVariant},
    Parser as PestParser, Span,
};

/// The Parser object that was generated by [`pest`], used to generate the parse tree
#[derive(Parser)]
#[grammar = "grammar.pest"]
pub struct LsParser;

pub type SpanVec<'a> = Vec<Span<'a>>;

/// Result type of [`to_ast`]
pub type ParseResult<T> = Result<T, Error<Rule>>;

pub type Pair<'a> = pest::iterators::Pair<'a, Rule>;
pub type Pairs<'a> = pest::iterators::Pairs<'a, Rule>;

/// converts a `pest::iterators::Pairs` to an [ast](crate::core::Block)
/// You can obtain an instance of pairs from [`LsParser::parse`]
pub fn to_ast(mut pairs: Pairs) -> ParseResult<(Block, SpanVec)> {
    let mut span_vec = vec![];
    let block_pair = pairs.next().unwrap();
    assert!(matches!(pairs.next().unwrap().as_rule(), Rule::EOI));
    let res = parse_block(block_pair, &mut span_vec)?;
    Ok((res, span_vec))
}

fn parse_block<'a>(pair: Pair<'a>, span_vec: &mut SpanVec<'a>) -> ParseResult<Block> {
    let id = span_vec.len();
    span_vec.push(pair.as_span());
    assert!(matches!(pair.as_rule(), Rule::block));

    let phrases = pair
        .into_inner()
        .map(|p| parse_phrase(p, span_vec))
        .collect::<Result<_, _>>()?;
    Ok(Block(id, phrases))
}

fn parse_phrase<'a>(pair: Pair<'a>, span_vec: &mut SpanVec<'a>) -> ParseResult<Phrase> {
    assert!(matches!(pair.as_rule(), Rule::phrase));

    let child = get_single_child(pair.into_inner());
    match child.as_rule() {
        Rule::expression => Ok(Phrase::Expr(parse_expression(child, span_vec)?)),
        _ => unreachable!(),
    }
}

fn parse_expression<'a>(pair: Pair<'a>, span_vec: &mut SpanVec<'a>) -> ParseResult<Expr> {
    assert!(matches!(pair.as_rule(), Rule::expression | Rule::callee));

    let child = get_single_child(pair.into_inner());
    Ok(match child.as_rule() {
        Rule::block_expression => parse_block_expr(child, span_vec)?.into(),
        Rule::x_expression => parse_x_expression(child, span_vec)?.into(),
        Rule::str_lit => parse_str_lit(child, span_vec)?.into(),
        Rule::let_expr => parse_let_expr(child, span_vec)?.into(),
        Rule::int_lit => parse_int_lit(child, span_vec)?.into(),
        Rule::symbol => parse_symbol_expr(child, span_vec)?.into(),
        Rule::call => parse_call_expr(child, span_vec)?.into(),
        Rule::fragment_def => parse_fragment_def(child, span_vec)?.into(),
        _ => unreachable!(),
    })
}

fn parse_fragment_def<'a>(pair: Pair<'a>, span_vec: &mut SpanVec<'a>) -> ParseResult<FnFragment> {
    let id = span_vec.len();
    span_vec.push(pair.as_span());
    assert!(matches!(pair.as_rule(), Rule::fragment_def));

    let mut children: Vec<Pair> = pair.into_inner().collect();
    let body = parse_expression(children.pop().unwrap(), span_vec)?;
    Ok(FnFragment {
        id,
        arg_names: to_str_vec(children),
        body: Box::new(body),
    })
}

fn parse_call_expr<'a>(pair: Pair<'a>, span_vec: &mut SpanVec<'a>) -> ParseResult<Call> {
    let id = span_vec.len();
    span_vec.push(pair.as_span());
    assert!(matches!(pair.as_rule(), Rule::call));

    let mut children = pair.into_inner().map(|p| parse_expression(p, span_vec));
    let callee = children.next().unwrap()?;
    let args = children.collect::<Result<_, _>>()?;
    Ok(Call {
        id,
        callee: Box::new(callee),
        args,
    })
}

fn parse_block_expr<'a>(pair: Pair<'a>, span_vec: &mut SpanVec<'a>) -> ParseResult<Block> {
    assert!(matches!(pair.as_rule(), Rule::block_expression));
    let child = get_single_child(pair.into_inner());
    parse_block(child, span_vec)
}

fn parse_symbol_expr<'a>(pair: Pair<'a>, span_vec: &mut SpanVec<'a>) -> ParseResult<Symbol> {
    let id = span_vec.len();
    span_vec.push(pair.as_span());
    assert!(matches!(pair.as_rule(), Rule::symbol));
    Ok(Symbol(id, pair.as_str().into()))
}

fn parse_int_lit<'a>(pair: Pair<'a>, span_vec: &mut SpanVec<'a>) -> ParseResult<IntLit> {
    let id = span_vec.len();
    span_vec.push(pair.as_span());
    assert!(matches!(pair.as_rule(), Rule::int_lit));
    let val_str = pair.as_str().replace("_", "");
    let val = if val_str.starts_with("0x") {
        i64::from_str_radix(&val_str[2..], 16).unwrap()
    } else if val_str.starts_with("-0x") {
        -i64::from_str_radix(&val_str[3..], 16).unwrap()
    } else {
        val_str
            .parse::<i64>()
            .expect(&format!("cant parse {} as i64", val_str))
    };
    Ok(IntLit(id, val))
}

fn parse_let_expr<'a>(pair: Pair<'a>, span_vec: &mut SpanVec<'a>) -> ParseResult<Let> {
    let id = span_vec.len();
    span_vec.push(pair.as_span());
    assert!(matches!(pair.as_rule(), Rule::let_expr));

    let mut children = pair.into_inner();
    Ok(Let {
        id,
        symbol_name: children.next().unwrap().as_str().into(),
        value_expr: Box::new(parse_expression(children.next().unwrap(), span_vec)?),
    })
}

fn parse_str_lit<'a>(pair: Pair<'a>, span_vec: &mut SpanVec<'a>) -> ParseResult<Expr> {
    let id = span_vec.len();
    span_vec.push(pair.as_span());
    assert!(matches!(pair.as_rule(), Rule::str_lit));

    // A strlit is either quoted or single_quoted, that makes a different in the grammar,
    // but the structure is the same, so we just go one lvl deeper
    let pair = get_single_child(pair.into_inner());
    let children: Vec<_> = pair
        .clone()
        .into_inner()
        .map(|p| parse_str_lit_elem(p, span_vec))
        .collect::<Result<_, _>>()?;
    Ok(if children.len() == 1 {
        children[0].clone()
    } else {
        span_vec.push(pair.as_span());
        Call {
            callee: Box::new(Symbol(id + 1, "strcat".into()).into()),
            args: children,
            id,
        }
        .into()
    })
}

fn parse_str_lit_elem<'a>(pair: Pair<'a>, span_vec: &mut SpanVec<'a>) -> ParseResult<Expr> {
    let id = span_vec.len();
    span_vec.push(pair.as_span());
    assert!(matches!(pair.as_rule(), Rule::quoted_str_lit_elem));

    let child = get_single_child(pair.into_inner());
    Ok(match child.as_rule() {
        Rule::pure_quoted_str_lit => StrLit(id, child.as_str().into()).into(),
        Rule::symbol => Symbol(id, child.as_str().into()).into(),
        Rule::expression => parse_expression(child, span_vec)?,
        _ => unreachable!(),
    })
}

fn parse_x_expression<'a>(pair: Pair<'a>, span_vec: &mut SpanVec<'a>) -> ParseResult<Call> {
    let id = span_vec.len();
    span_vec.push(pair.as_span());
    // this is pushed twice because we will insert an Expr node for the built in call, which does not
    // have a span. So we reuse the span of the Xexpr. Since the ID is based on the span vec, this is
    // necessary so the symbol node can have it's own id
    span_vec.push(pair.as_span());
    assert!(matches!(pair.as_rule(), Rule::x_expression));

    let args: Vec<Expr> = pair
        .into_inner()
        .map(|p| parse_xexpr_atom(p, span_vec))
        .collect::<Result<_, _>>()?;

    Ok(Call {
        callee: Box::new(Symbol(id + 1, "exec".into()).into()),
        args,
        id,
    })
}

fn parse_xexpr_atom<'a>(pair: Pair<'a>, span_vec: &mut SpanVec<'a>) -> ParseResult<Expr> {
    let id = span_vec.len();
    span_vec.push(pair.as_span());
    assert!(matches!(pair.as_rule(), Rule::xexpr_elem));

    let child = get_single_child(pair.into_inner());
    Ok(match child.as_rule() {
        Rule::symbol => Symbol(id, child.as_str().into()).into(),
        Rule::xexpr_str => StrLit(id, child.as_str().into()).into(),
        _ => unreachable!(),
    })
}

fn get_single_child(p: Pairs) -> Pair {
    let children: Vec<Pair> = p.collect();
    assert!(
        children.len() == 1,
        "get_single_child found {} children in {:#?}",
        children.len(),
        children
    );
    children[0].clone()
}
