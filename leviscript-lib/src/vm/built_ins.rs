//! Contains the built ins
//!
//! The idea is the following: during execution, the build in opcode
//! calls dispatch_built_in, which then calls the actual build in function
//! via the apropriate wrapper.
//! The wrapper handles the interaction between the stack and the built in
//! Additionally, there is the BUILT_INS Dict, which allows to find out the
//! built ins signature at compile time.
//! the dispatch-fn, the dict and the wrappers will be generated by a proc macro
//! on the impls mod, once I've got everything working

use crate::core::*;
use crate::vm::{rt_assert, rt_err, Error, Result, Stack};
use std::any::type_name;
use std::process;

pub mod impls {
    use super::*;

    pub unsafe fn exec(bin_name: *const String, args: Vec<*const String>) -> Result<()> {
        let stat = process::Command::new(&*bin_name)
            .args(args.iter().map(|a| &**a))
            .status()
            .map_err(|e| rt_err!("Executing {}: {}", &*bin_name, e))?;
        rt_assert!(
            stat.success(),
            "{} did not execute successfully",
            &*bin_name
        );
        Ok(())
    }

    pub unsafe fn strcat(strs: Vec<*const String>) -> Result<String> {
        let strs: Vec<&str> = strs.iter().map(|v| (&**v).as_ref()).collect();
        Ok(strs.join(""))
    }
}

fn signatures(f_name: &str) -> Option<&'static Signature> {
    Some(match f_name {
        "exec" => &Signature {
            args: vec![DataType::Str, DataType::vec(DataType::Str)],
            result: DataType::Unit,
        },
        "strcat" => &Signature {
            args: vec![DataType::vec(DataType::Str)],
            result: DataType::Str,
        },
        _ => {
            return None;
        }
    })
}

pub fn wrapper_0(f: fn() -> Result<()>) -> Result<()>
where
{
    f()
}

pub fn wrapper_0_ret<R>(f: fn() -> Result<R>, stack: &mut Stack) -> Result<()>
where
    R: Into<Value>,
{
    let res: Value = f()?.into();
    stack.push_val_and_ref(res);
    Ok(())
}

pub unsafe fn wrapper_1<T1>(f: fn(T1) -> Result<()>, f_name: &str, stack: &mut Stack) -> Result<()>
where
    Data: GetDataAs<T1>,
{
    let d1 = pop_data(stack, f_name)?;
    let a1 = get_data_as(&d1)?;
    f(a1)?;
    Ok(())
}

pub unsafe fn wrapper_1_ret<R, T1>(
    f: unsafe fn(T1) -> Result<R>,
    f_name: &str,
    stack: &mut Stack,
) -> Result<()>
where
    Data: GetDataAs<T1>,
    R: Into<Value>,
{
    let d1 = pop_data(stack, f_name)?;
    let a1 = get_data_as(&d1)?;
    let res = f(a1)?;
    stack.push_val_and_ref(res.into());
    Ok(())
}

pub unsafe fn wrapper_2<T1, T2>(
    f: unsafe fn(T1, T2) -> Result<()>,
    f_name: &str,
    stack: &mut Stack,
) -> Result<()>
where
    Data: GetDataAs<T1>,
    Data: GetDataAs<T2>,
{
    let d1 = pop_data(stack, f_name)?;
    let d2 = pop_data(stack, f_name)?;
    let a1 = get_data_as(&d1)?;
    let a2 = get_data_as(&d2)?;
    f(a1, a2)
}

pub unsafe fn wrapper_2_ret<R, T1, T2>(
    f: unsafe fn(T1, T2) -> Result<R>,
    f_name: &str,
    stack: &mut Stack,
) -> Result<()>
where
    Data: GetDataAs<T1>,
    Data: GetDataAs<T2>,
    R: Into<Value>,
{
    let d1 = pop_data(stack, f_name)?;
    let d2 = pop_data(stack, f_name)?;
    let a1 = get_data_as(&d1)?;
    let a2 = get_data_as(&d2)?;
    let res = f(a1, a2)?;
    stack.push_val_and_ref(res.into());
    Ok(())
}

/// pops data from the stack, and casts the StackEntry to Data.
/// Also does error handling
fn pop_data(stack: &mut Stack, f_name: &str) -> Result<Data> {
    stack
        .pop()
        .ok_or_else(|| Error::StackEmpty(format!("During call to built in: {}", f_name)))?
        .try_into()
        .map_err(|_| Error::UnexpectedStackEntry {
            index: stack.len(),
            msg: format!("during call to built in: {}", f_name),
        })
}

unsafe fn get_data_as<T>(d: &Data) -> Result<T>
where
    Data: GetDataAs<T>,
{
    d.get_as().ok_or_else(|| Error::TypeError {
        accessed_data: d.clone(),
        expected_type: type_name::<T>(),
    })
}
