//! Contains the built ins
//!
//! The idea is the following: during execution, the build in opcode
//! calls dispatch_built_in, which then calls the actual build in function
//! via the apropriate wrapper.
//! The wrapper handles the interaction between the stack and the built in
//! Additionally, there is the BUILT_INS Dict, which allows to find out the
//! built ins signature at compile time.
//! the dispatch-fn, the dict and the wrappers will be generated by a proc macro
//! on the impls mod, once I've got everything working

use crate::core::*;
use crate::vm::*;

use std::any::type_name;
use std::fmt::Debug;
use std::process;

pub mod impls {
    use super::*;

    pub unsafe fn exec(bin_name: *const String, args: Vec<*const String>) -> Result<()> {
        let stat = process::Command::new(&*bin_name)
            .args(args.iter().map(|a| &**a))
            .status()
            .map_err(|e| rt_err!("Executing {}: {}", &*bin_name, e))?;
        rt_assert!(
            stat.success(),
            "{} did not execute successfully",
            &*bin_name
        );
        Ok(())
    }

    pub unsafe fn strcat(strs: Vec<*const String>) -> Result<String> {
        let strs: Vec<&str> = strs.iter().map(|v| (&**v).as_ref()).collect();
        Ok(strs.join(""))
    }
}

fn signatures(f_name: &str) -> Option<Signature> {
    Some(match f_name {
        "exec" => Signature {
            args: vec![DataType::Str, DataType::vec(DataType::Str)],
            result: DataType::Unit,
        },
        "strcat" => Signature {
            args: vec![DataType::vec(DataType::Str)],
            result: DataType::Str,
        },
        _ => {
            return None;
        }
    })
}

pub unsafe fn wrapper_0_var_ret<R, T1>(
    f: unsafe fn(Vec<T1>) -> Result<R>,
    f_name: &str,
    mem: &mut Memory,
) -> Result<()>
where
    T1: TryFromRef<RuntimeData> + Debug,
    R: Into<Storable> + Debug,
{
    let n = pop_stack(mem, f_name)?;
    let n = get_data_as::<i64>(&n)? as usize;
    let mut args: Vec<T1> = Vec::with_capacity(n);
    args.set_len(n);
    for i in 0..n {
        // you might think this doesn't work because we kill the object we get a ref from
        // but it's either a ref, in which case the actual value lives somewhere else, and the
        // ref is copy. Or it's a primitive value, which is copy anyway
        let arg = pop_stack(mem, f_name)?;
        let val = get_data_as::<T1>(&arg)?;
        *args.get_unchecked_mut(n - 1 - i) = val;
    }
    let s_entry = f(args)?.into();
    mem.store(s_entry);
    Ok(())
}

pub unsafe fn wrapper_1_var<T1, T2>(
    f: unsafe fn(T1, Vec<T2>) -> Result<()>,
    f_name: &str,
    mem: &mut Memory,
) -> Result<()>
where
    T1: TryFromRef<RuntimeData>,
    T2: TryFromRef<RuntimeData>,
{
    let n = pop_stack(mem, f_name)?;
    let n = get_data_as::<i64>(&n)? as usize;
    let mut args: Vec<T2> = Vec::with_capacity(n);
    args.set_len(n);
    for i in 0..n {
        // you might think this doesn't work because we kill the object we get a ref from
        // but it's either a ref, in which case the actual value lives somewhere else, and the
        // ref is copy. Or it's a primitive value, which is copy anyway
        let arg = pop_stack(mem, f_name)?;
        let val = get_data_as::<T2>(&arg)?;
        *args.get_unchecked_mut(n - 1 - i) = val;
    }
    let d1 = pop_stack(mem, f_name)?;
    let a1 = get_data_as(&d1)?;
    f(a1, args)
}

/// pops data from the stack, and casts the StackEntry to RuntimeData.
/// Also does error handling
fn pop_stack(mem: &mut Memory, f_name: &str) -> Result<RuntimeData> {
    mem.stack
        .pop()
        .ok_or_else(|| Error::StackEmpty(format!("During call to built in: {}", f_name)))
}

unsafe fn get_data_as<T>(d: &RuntimeData) -> Result<T>
where
    T: TryFromRef<RuntimeData>,
{
    d.rtry_into().ok_or_else(|| Error::TypeError {
        accessed_data: d.clone(),
        expected_type: type_name::<T>(),
    })
}
