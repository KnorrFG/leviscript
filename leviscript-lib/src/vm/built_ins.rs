//! Contains the built ins
//!
//! The idea is the following: during execution, the build in opcode
//! calls dispatch_built_in, which then calls the actual build in function
//! via the apropriate wrapper.
//! The wrapper handles the interaction between the stack and the built in
//! Additionally, there is the BUILT_INS Dict, which allows to find out the
//! built ins signature at compile time.
//! the dispatch-fn, the dict and the wrappers will be generated by a proc macro
//! on the impls mod, once I've got everything working

use crate::core::*;
use crate::vm::*;

use std::any::type_name;
use std::fmt::Debug;
use std::process;

pub mod impls {
    use super::*;

    pub unsafe fn exec(bin_name: *const String, args: Vec<*const String>) -> Result<()> {
        let stat = process::Command::new(&*bin_name)
            .args(args.iter().map(|a| &**a))
            .status()
            .map_err(|e| rt_err!("Executing {}: {}", &*bin_name, e))?;
        rt_assert!(
            stat.success(),
            "{} did not execute successfully",
            &*bin_name
        );
        Ok(())
    }

    pub unsafe fn strcat(strs: Vec<*const String>) -> Result<String> {
        let strs: Vec<&str> = strs.iter().map(|v| (&**v).as_ref()).collect();
        Ok(strs.join(""))
    }
}

pub const BUILT_INS: [&'static str; 2] = ["exec", "strcat"];

pub fn signatures(f_name: &str) -> Option<Signature> {
    Some(match f_name {
        "exec" => Signature::new()
            .arg(DataType::str().into())
            .variadic(DataType::str().into()),
        "strcat" => Signature::new()
            .variadic(DataType::str().into())
            .result(DataType::str().into()),
        _ => {
            return None;
        }
    })
}

pub fn opcode(f_name: &str) -> Option<OpCode> {
    Some(match f_name {
        "exec" => OpCode::Exec,
        "strcat" => OpCode::StrCat,
        _ => return None,
    })
}

pub unsafe fn wrapper_0_var_ret<R, T1>(
    f: unsafe fn(Vec<T1>) -> Result<R>,
    f_name: &str,
    mem: &mut Memory,
) -> Result<()>
where
    T1: TryFromRef<RuntimeData> + Debug,
    R: Into<Storable> + Debug,
{
    let n = mem.stack_back(0);
    let n = get_data_as::<i64>(n)? as usize;
    let mut args: Vec<T1> = Vec::with_capacity(n);
    args.set_len(n);
    for i in 0..n {
        // you might think this doesn't work because we kill the object we get a ref from
        // but it's either a ref, in which case the actual value lives somewhere else, and the
        // ref is copy. Or it's a primitive value, which is copy anyway
        let arg = mem.stack_back(i + 1);
        let val = get_data_as::<T1>(arg)?;
        *args.get_unchecked_mut(n - 1 - i) = val;
    }
    let s_entry = f(args)?.into();
    mem.store(s_entry);
    Ok(())
}

pub unsafe fn wrapper_1_var<T1, T2>(
    f: unsafe fn(T1, Vec<T2>) -> Result<()>,
    f_name: &str,
    mem: &mut Memory,
) -> Result<()>
where
    T1: TryFromRef<RuntimeData>,
    T2: TryFromRef<RuntimeData>,
{
    let n = mem.stack_back(0);
    let n = get_data_as::<i64>(n)? as usize;
    let mut args: Vec<T2> = Vec::with_capacity(n);
    args.set_len(n);
    for i in 0..n {
        // you might think this doesn't work because we kill the object we get a ref from
        // but it's either a ref, in which case the actual value lives somewhere else, and the
        // ref is copy. Or it's a primitive value, which is copy anyway
        let arg = mem.stack_back(i + 1);
        let val = get_data_as::<T2>(arg)?;
        *args.get_unchecked_mut(n - 1 - i) = val;
    }
    let d1 = mem.stack_back(n + 1);
    let a1 = get_data_as(d1)?;
    f(a1, args)?;
    mem.store(CopyValue::Unit.into());
    Ok(())
}

unsafe fn get_data_as<T>(d: &RuntimeData) -> Result<T>
where
    T: TryFromRef<RuntimeData>,
{
    d.rtry_into().ok_or_else(|| Error::TypeError {
        accessed_data: d.clone(),
        expected_type: type_name::<T>(),
    })
}
